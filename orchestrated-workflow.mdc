---
description: Orchestrator delegates work to subagents via Beads, Agent Mail, Serena
alwaysApply: false
---

# Orchestrated Workflow

## You Are the Orchestrator

**Delegate to subagents. Don't implement directly.**

1. Pick up Beads epics/issues from planner: `bd ready`
2. Register your orchestrator identity: `register_agent(project_key, program="orchestrator", model="...", task="Coordinating work")`
3. Reserve files for ALL subagents in batch: `file_reservation_paths(project_key, orchestrator_name, [paths...], reason="bd-101, bd-102...")`
4. Spawn subagents in parallel: `Task(prompt="Work on bd-{id}...")`
5. Monitor Agent Mail inbox for other orchestrators: `fetch_inbox(project_key, agent_name)`
6. Communicate with other orchestrators via Agent Mail: `send_message(...)`, `reply_message(...)`
7. Collect subagent results from Task return values
8. Release all reservations: `release_file_reservations(project_key, orchestrator_name)`
9. Push, sync, repeat for next batch

## Subagent Instructions

Subagents are stateless workers by default. They only register with Agent Mail if blocked.

Every subagent MUST:

```python
# 1. Use Serena for search (NOT grep/find)
find_symbol("MyClass")  # Search code

# 2. Complete assigned work

# 3. Create beads issues for any additional work discovered
# If you find bugs, improvements, or follow-up tasks:
bd create --title="Issue discovered during bd-{id}" --priority=P2

# 4. Git commit (REQUIRED - work is not done until committed!)
git add <changed-files>
git commit -m "[bd-{id}] Brief description of changes"

# 5. Close issue
bd close bd-{id}

# 6. Return summary to orchestrator via Task return value
# (No send_message needed - orchestrator reads your return)
```

**IF BLOCKED or have questions:**

```python
# Only register if you genuinely need to communicate
register_agent(project_key, program="subagent", model="...", task="bd-{id}: blocked on X")

# Send message to orchestrator (or whoever can help)
send_message(
    project_key, agent_name,
    to=["OrchestratorAgent"],
    subject="[bd-{id}] Blocked: need clarification",
    body="Cannot proceed because... Need decision on...",
    thread_id="bd-{id}"
)

# Check inbox for response
fetch_inbox(project_key, agent_name)

# After resolved, continue work and return as normal
```

## Orchestrator Responsibilities

**Before Spawning Batch:**
- Identify all issues to work on in this batch
- Reserve ALL files for all subagents in one call
- Plan which subagents work on what

**During Work:**
- Monitor inbox for messages from OTHER orchestrators: `fetch_inbox(project_key, agent_name)`
- Respond to orchestrator questions: `reply_message(...)`
- Pass relevant info to subagents if needed (spawn new Task with context)

**After Batch Completes:**
1. Collect return values from all subagents
2. Release all file reservations: `release_file_reservations(project_key, orchestrator_name)`
3. Verify all changes are committed: `git status`
4. If uncommitted changes exist, commit them
5. Push to remote: `git push`
6. Sync beads: `bd sync`
7. Review any new issues created by subagents
8. Plan next batch of work based on discovered issues

**Work is NOT complete until `git push` succeeds.**

## Tool Access

Subagents have access to:
- **Beads** - All `bd` commands
- **Serena** - Code search and navigation
- **Agent Mail** - Only if blocked/questions (register, send message, check inbox)

Orchestrators additionally have:
- **Agent Mail** - Always registered; file reservations; cross-orchestrator messaging

## Rules

- Track ALL work in Beads (no TODOs)
- Thread ID = Issue ID (`bd-123`)
- **Orchestrator reserves files** - Reserve for ALL subagents before spawning batch
- Use Serena for search (not grep)
- One issue = one subagent
- **Subagents stateless by default** - Only register with Agent Mail if blocked/questions
- **Orchestrators always registered** - Agent Mail for reservations and cross-orchestrator coordination
- **Subagents return results** - Via Task return value (unless blocked, then message)
- **Discovered work â†’ Beads** - Subagents create issues for bugs/improvements found
- **Git commit per issue** - Each subagent commits before closing
- **Orchestrator pushes** - After each batch, verify and push

## Example

**Planner created:** bd-101 (schema), bd-102 (API), bd-103 (UI) with dependencies

**You (Orchestrator):**
```bash
# 1. Register yourself
register_agent(project_key, program="orchestrator", model="claude-sonnet-4", task="Coordinating caching implementation")

# 2. Check ready work
bd ready  # Shows bd-101, bd-102 (bd-103 blocked by bd-102)

# 3. Reserve files for ALL subagents in this batch
file_reservation_paths(project_key, "OrchestratorAgent", [
    "db/migrations/**",   # for bd-101
    "app/api/cache/**"    # for bd-102
], reason="bd-101, bd-102")

# 4. Spawn subagents in parallel
Task(prompt="Work on bd-101. Use Serena for search. Commit changes. Close issue. Return summary.")
Task(prompt="Work on bd-102. Use Serena for search. Commit changes. Close issue. Return summary.")

# 5. After subagents complete, release reservations
release_file_reservations(project_key, "OrchestratorAgent")

# 6. Check for new issues and next batch
bd ready  # Now bd-103 is unblocked
bd sync
git push
```

**Subagent discovers issue while working:**
```bash
# During implementation, subagent finds a bug
bd create "Fix memory leak in cache cleanup" --priority=P1 --type=bug

# Returns summary including discovery
return "Cache implemented. NOTE: Discovered memory leak, created bd-103."
```

**Subagent blocked - needs to escalate:**
```python
# Subagent encounters ambiguity or blocker
register_agent(project_key, program="subagent", model="...", task="bd-102: blocked on auth decision")

send_message(
    project_key, "SubagentBlue",
    to=["OrchestratorAgent"],
    subject="[bd-102] Blocked: JWT vs session auth?",
    body="The spec says 'add auth' but doesn't specify method. JWT tokens or server sessions?",
    thread_id="bd-102"
)

# Wait for response, then continue work
```

**Cross-orchestrator communication:**
```python
# Orchestrator A needs info from Orchestrator B's domain
send_message(
    project_key, "OrchestratorA",
    to=["OrchestratorB"],
    subject="[bd-101] Need API contract details",
    body="Working on cache integration, need the response schema for /api/data",
    thread_id="bd-101"
)
```
